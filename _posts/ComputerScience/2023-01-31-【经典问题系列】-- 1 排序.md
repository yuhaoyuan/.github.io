---
categories: ComputerScience
toc: true
---

# 前言

在计算机领域中，前人的智慧结晶成了经典的算法。 让我们来探究这些已经成为"基础"的问题吧。

PS：手把手教会你，学不会直接私信骂我。

# 背景

1 想象一下，给你一个随机的序列[45,8,12,7,15,46,83,2], 你能够将它按从小到大排序吗?   
相信你很快就能凭借人类拥有的智慧将它排好： [2,7,8,12,15,45,46,83]

2 接下来请描述你的方法，并且这种方法可以适用于所有情况。

3 如果上面的步骤你都能完成，那么想一想你的方法需要运算多少次?

4 可以尽量的减少算法的运算次数么？

下面让我们看看历史上人类智慧的光芒吧。   
（假设这个需要排序的数组名称为array 其长度为n  
（讨论次数和复杂度时，默认都是讨论渐进复杂度，即当 n 趋近于无穷大， 比如 O(n^2 /2) 认为是 O(n^2)

# 新手：冒泡排序(Bubble Sort)

思路：
最朴素的思想即可，每次找出最小/大的数字，按排序要求，将其放到数组的最前/后一位

实现：

1. 从前到后比较相邻的元素，按 顺序/逆序 交换它们的顺序，即找到最小/大的数。
2. 一轮过后，最后的元素将是最大/小的(按 顺序/逆序 规则)
3. 在剩余数组中重复

```
伪代码
    循环： i 从 0 到 ( n - 1)
        循环： j 从 0 到 (n - 2 - i)
            如果 array[j] > array[j + 1]
                交换 array[j] 和 array[j + 1] 的值
            如果结束
        j循环结束
    i循环结束
函数结束
```

比较次数：    
可以看出来第一轮需要比较 n-2 次, 然后每轮少一次，一直到最后一轮比较一次，比较次数是 (n-1)n/2。

交换次数：  
最坏的情况下(比如将一个顺序的数组排列成倒序)，同比较次数一样，(n-1)n/2次  
最好的情况下，无须交换。

渐进时间复杂度：   
O(n^2)

空间：  
除了交换无须申请新的存储空间，可以进行原地排序

优化思路：  
假设一个数据已经有序，按现有的思路和做法，依然会进行同样的比较逻辑，这是没必要的浪费。  
所以我们可以对这种情况进行优化，即如果


---

# 青铜： 选择排序 (Selection sort)

思路：
最朴素的思想即可，每次找出最小/大的数字，按排序要求，将其放到数组的最前/后一位  
（思路和冒泡排序基本一致，实现方法不同）

实现：

1. 从前到后找到最小/大值，和最前/后交换
2. 在剩余的数组中重复

```
伪代码
    循环： i 从 0 到 ( n - 1)
        最小值min位置初始化为i
        循环： j 从 i+1 到 (n - 1)
            如果 array[i] > array[j]
                更新最小值位置为j
            如果结束
        j循环结束
        交换 array[i] 和 array[min]
    i循环结束
函数结束
```

比较次数：    
所以任何情况下都需要比较约(n-1)n/2次

交换次数：  
最坏的情况下，为n-1次  
最好的情况下，无须交换。   
比冒泡排序好的地方在于：如果一个值处于正确的位置，那么它不会被移动。

渐进时间复杂度：   
O(n^2)

空间：  
除了交换无须申请新的存储空间，可以进行原地排序

优化思路：




---

# 黄金： 插入排序 (Insertion Sort)

思路：  
想象自己在摸扑克牌，首先摸到[45], 假设有这张牌   
然后摸到8，把8放在45前面，即[8, 45]  
摸到12，把12放在8和45之间，即[8,12,45]  
摸到7，把7放在最前面，即[7,8,12,45]  
...  
重复这个过程就完成了插入排序

实现：

1. 在需要插入的数字时，前方的数组已经有序，从后向前找到第一个小于它的数
2. 将此数插入，并将后面数字挪动
3. 重复此过程

```
伪代码
    循环： i 从 1 到 (n - 1)
        // 新加入的数为array[i]
        循环： j 从 i-1 到 0
            如果 array[j+1] < array[j]
                交换    // 相当于把array[j]往后移动一位
            否则
                说明 j+1(新加入的数) >= j (第一个小于它的数)，都处于正确位置
                跳出j循环
            如果结束
        j循环结束
    i循环结束
函数结束
```

比较次数：    
最好情况下，比较n-1次即可
最坏情况下，需要比较(n-1)n/2次

交换次数：
最好情况下，无须交换
最坏情况下，交换次数为(n-1)n/2次

渐进时间复杂度：   
O(n^2)

空间：  
除了交换无须申请新的存储空间，可以进行原地排序

优化思路：

1. 希尔排序

其他：  
插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。

---

# 希尔排序

思路：  
插入排序在面对有序的数列时，其效果非常好，效率非常高。  
但是面对非有序数组时，新插入的数字(假设是一个很小的数)每次只能移动一位，所以效率比较低。

那么朴素的优化方法就是扩大步长，让一个很小的数每次可以向前移动多位。  
举个栗子，假设步长为5，对这组数组排序[13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10]  
则相当于拆解成5列：  
[13, 25, 45, 10]、[14, 59, 27] 、[94, 94, 73] 、[33, 65, 25] 、[82, 23, 39]

转换一下为：   
13 14 94 33 82  
25 59 94 65 23  
45 27 73 25 39  
10

然后相当于对这5列进行插入排序，   
10 14 73 25 23   
13 27 94 33 39   
25 59 94 65 82   
45

此时的数组已经变成了：   
[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]   
这时10已经从最后一位，只交换了三次，就移至正确位置了

然后再以3为步长进行排序：
10 14 73    
25 23 13    
27 94 33    
39 25 59    
94 65 82    
45

排序之后变为：    
10 14 13    
25 23 33    
27 25 59    
39 65 73    
45 94 82    
94    
此时的数组已经变成了：     
[ 10 14 13 25 23 33 27 25 59 39 65 73 45 94 82 94 ]

最后再以步长为1，进行排序。 (即插入排序)
总共比较和交换次数已经大大减少。

那么步长该如何设置呢？ 比如对一个长度为100000的数组，初始步长选择多少？

希尔最初提出： 取 [n/2, n/4 ... 1]这个序列的步长，但最坏的情况下还是O(n^2)

已知的最好步长序列是由Sedgewick提出的[1, 5, 19, 41, 109,...]，该序列的项，
从第0项开始，偶数项来自序列[ 9 * 4^i - 9 * 2^i + 1 ]     
奇数项来自序列： [ 2^(i+2) * (2^(i+2) -3) + 1]   
[来源](https://web.archive.org/web/20190427051559/http://faculty.simpson.edu/lydia.sinapova/www/cmsc250/LN250_Weiss/L12-ShellSort.htm#increments)


伪代码：



复杂度：
平均性能被认为是大约O( n^(5/4) )
该算法的确切复杂性仍在争论中。。。



---
快速排序

---
归并排序

---
堆排序

---
基数排序




