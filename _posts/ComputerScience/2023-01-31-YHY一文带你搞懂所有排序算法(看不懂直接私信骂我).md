---
categories: ComputerScience
toc: true
---

# 前言

在计算机领域中，前人的智慧结晶成了经典的算法。 今天YHY和您一起搞懂这些已经成为"基础"的问题！ 

PS：手把手教会你，学不会/看不懂gif图，您直接私信骂我。

# 背景

1 先随机生成的序列[45,8,12,7,15,46,83,2], 你能够将它按从小到大排序吗?   
相信你很快就能凭借人类拥有的智慧将它排好： [2,7,8,12,15,45,46,83]

2 接下来请描述你的方法，并且这种方法可以适用于所有情况。

3 如果上面的步骤你都能完成，那么想一想你的方法需要运算多少次?

4 可以尽量的减少算法的运算次数么？

下面让我们看看历史上人类智慧的光芒吧。   
（假设这个需要排序的数组名称为array 其长度为n  
（讨论次数和复杂度时，默认都是讨论渐进复杂度，即当 n 趋近于无穷大， 比如 O(n^2 /2) 认为是 O(n^2)

# 新手：冒泡排序(Bubble Sort)

思路：
最朴素的思想即可，每次找出最小/大的数字，按排序要求，将其放到数组的最前/后一位

实现：

1. 从前到后比较相邻的元素，按 顺序/逆序 交换它们的顺序，即找到最小/大的数。
2. 一轮过后，最后的元素将是最大/小的(按 顺序/逆序 规则)
3. 在剩余数组中重复

Bubble Sort 算法流程 Gif：    
<img src="https://github.com/yuhaoyuan/yuhaoyuan.github.io/raw/main/assets/computer_science/bubble_sort.gif" width="720px" height="540px" alt="merge_sort">


```
伪代码
    循环： i 从 0 到 ( n - 1)
        循环： j 从 0 到 (n - 2 - i)
            如果 array[j] > array[j + 1]
                交换 array[j] 和 array[j + 1] 的值
            如果结束
        j循环结束
    i循环结束
函数结束
```

比较次数：    
可以看出来第一轮需要比较 n-2 次, 然后每轮少一次，一直到最后一轮比较一次，比较次数是 (n-1)n/2。

交换次数：  
最坏的情况下(比如将一个顺序的数组排列成倒序)，同比较次数一样，(n-1)n/2次  
最好的情况下，无须交换。

渐进时间复杂度：   
O(n^2)

空间：  
除了交换无须申请新的存储空间，可以进行原地排序

优化思路：  
假设一个数据已经有序，按现有的思路和做法，依然会进行同样的比较逻辑，这是没必要的浪费。  
所以我们可以对这种情况进行优化，即如果


---

# 青铜： 选择排序 (Selection sort)

思路：
最朴素的思想即可，每次找出最小/大的数字，按排序要求，将其放到数组的最前/后一位  
（思路和冒泡排序基本一致，实现方法不同）

实现：

1. 从前到后找到最小/大值，和最前/后交换
2. 在剩余的数组中重复

Merge Sort 算法流程 Gif：     
<img src="https://github.com/yuhaoyuan/yuhaoyuan.github.io/raw/main/assets/computer_science/selection_sort.gif" width="720px" height="540px" alt="merge_sort">

```
伪代码
    循环： i 从 0 到 ( n - 1)
        最小值min位置初始化为i
        循环： j 从 i+1 到 (n - 1)
            如果 array[i] > array[j]
                更新最小值位置为j
            如果结束
        j循环结束
        交换 array[i] 和 array[min]
    i循环结束
函数结束
```

比较次数：    
所以任何情况下都需要比较约(n-1)n/2次

交换次数：  
最坏的情况下，为n-1次  
最好的情况下，无须交换。   
比冒泡排序好的地方在于：如果一个值处于正确的位置，那么它不会被移动。

渐进时间复杂度：   
O(n^2)

空间：  
除了交换无须申请新的存储空间，可以进行原地排序

优化思路：




---

# 黄金： 插入排序 (Insertion Sort)

思路：  
想象自己在摸扑克牌，首先摸到[45], 假设有这张牌   
然后摸到8，把8放在45前面，即[8, 45]  
摸到12，把12放在8和45之间，即[8,12,45]  
摸到7，把7放在最前面，即[7,8,12,45]  
...  
重复这个过程就完成了插入排序

实现：

1. 在需要插入的数字时，前方的数组已经有序，从后向前找到第一个小于它的数
2. 将此数插入，并将后面数字挪动
3. 重复此过程

```
伪代码
    循环： i 从 1 到 (n - 1)
        // 新加入的数为array[i]
        循环： j 从 i-1 到 0
            如果 array[j+1] < array[j]
                交换    // 相当于把array[j]往后移动一位
            否则
                说明  array[j+1](新加入的数) >=  array[j] (第一个小于它的数)，都处于正确位置
                跳出j循环
            如果结束
        j循环结束
    i循环结束
函数结束
```

比较次数：    
最好情况下，比较n-1次即可
最坏情况下，需要比较(n-1)n/2次

交换次数：
最好情况下，无须交换
最坏情况下，交换次数为(n-1)n/2次

渐进时间复杂度：   
O(n^2)

空间：  
除了交换无须申请新的存储空间，可以进行原地排序

优化思路：

1. 希尔排序

其他：  
插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。

---

# 铂金： 希尔排序

思路：  
插入排序在面对有序的数列时，其效果非常好，效率非常高。  
但是面对非有序数组时，新插入的数字(假设是一个很小的数)每次只能移动一位，所以效率比较低。

那么朴素的优化方法就是扩大步长，让一个很小的数每次可以向前移动多位。  
举个栗子，假设步长为5，对这组数组排序[13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10]  
则相当于拆解成5列：  
[13, 25, 45, 10]、[14, 59, 27] 、[94, 94, 73] 、[33, 65, 25] 、[82, 23, 39]

转换一下为：   
13 14 94 33 82  
25 59 94 65 23  
45 27 73 25 39  
10

然后相当于对这5列进行插入排序，   
10 14 73 25 23   
13 27 94 33 39   
25 59 94 65 82   
45

此时的数组已经变成了：   
[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]   
这时10已经从最后一位，只交换了三次，就移至正确位置了

然后再以3为步长进行排序：
10 14 73    
25 23 13    
27 94 33    
39 25 59    
94 65 82    
45

排序之后变为：    
10 14 13    
25 23 33    
27 25 59    
39 65 73    
45 94 82    
94    
此时的数组已经变成了：     
[ 10 14 13 25 23 33 27 25 59 39 65 73 45 94 82 94 ]

最后再以步长为1，进行排序。 (即插入排序)
总共比较和交换次数已经大大减少。

那么步长该如何设置呢？ 比如对一个长度为100000的数组，初始步长选择多少？

希尔最初提出： 取 [n/2, n/4 ... 1]这个序列的步长，但最坏的情况下还是O(n^2)

```
伪代码：  
以希尔最初提出的[n/2, n/4 ... 1]这个序列为步长

循环 步长gap 从 n/2 到 1
    // 以此步长做插入排序
    循环： i 从 1 到 (n - 1)， i每次增加gap
        // 新加入的数为array[i]
        循环： j 从 i-gap 到 0
            如果 array[j+gap] < array[j]
                交换    // 相当于把array[j]往后移动gap位
            否则
                说明  array[j+gap](新加入的数) >=  array[j] (第一个小于它的数)，都处于正确位置
                跳出j循环
            如果结束
        j循环结束
    i循环结束
```

运算次数和复杂度：  
已知的最好步长序列是由Sedgewick提出的[1, 5, 19, 41, 109,...]，该序列的项，
从第0项开始，偶数项来自序列[ 9 * 4^i - 9 * 2^i + 1 ]     
奇数项来自序列： [ 2^(i+2) * (2^(i+2) -3) + 1]   
[来源](https://web.archive.org/web/20190427051559/http://faculty.simpson.edu/lydia.sinapova/www/cmsc250/LN250_Weiss/L12-ShellSort.htm#increments)
使用该步长的希尔排序在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。

平均性能被认为是大约O( n^(5/4) )   
该算法的确切复杂性仍在争论中。。。


---
# 归并排序(Merge Sort)   
作者是大名鼎鼎的冯·诺伊曼。  

思路：
分治法的典型应用(即把一个问题分解成若干简单子问题，该问题的解等于子问题解的合并)
- 分割：将一个数组分割成两个有序数组
- 合并：将两个有顺序的数组合并成同一个有顺序的数组


Merge Sort 算法流程 Gif：     
<img src="https://github.com/yuhaoyuan/yuhaoyuan.github.io/raw/main/assets/computer_science/merge_sort.gif" width="720px" height="540px" alt="merge_sort">

```
伪代码-递归：
全局变量-原array
全局变量-临时数组temp

func 分割(left, right):
    if left < right{
        mid = (left + right) / 2
        分割左边的序列(left, mid)
        分割左边的序列(mid+1,left)
        // 此时左边和右边的序列都已经有序
        合并两边的序列(left, mid, right)
    }
    
func 合并(left, mid, right)：
    // [left, mid] 和 [mid+1, right] 已经是两个有序数组
    // 因为更深的层已经被递归过，比如：假设此时是[1,2]，则[1,1],[2,2]已经有序，同理如果此时是[1,4]，则[1,2],[3,4]已经有序
    设置探针i = left
    设置探针j = mid + 1
    设置temp的下标初始值index = 0
    
    探针开始工作：当 i<=mid 并且 j <=right:
        比较 array[i] 和 array[j]
            将更小的值放入 temp
    
    将剩余的i或者j之后的数组放入temp
    
    // 此时temp为有序的 array[left~right]
    将temp中的值按顺序放入array中。
   
func main：
    分割(0, length(array))
```

比较次数：
递归可以认为有 logN 层   
最好情况下，即完全有序每一层只需要比较(right-left)/2的次数，总共比 logN * n / 2  次   
最坏情况下，每一层都比较接近n次,但其实无法做到，最优为 n * logN - n + 1 次      

赋值次数：
先放入temp，再放入array ，所以为 2 * n * logN 次

渐进时间复杂度：   
O(n*logN)

空间：  
申请和array同样大小的新空间

---
快速排序

---
堆排序

---
基数排序




